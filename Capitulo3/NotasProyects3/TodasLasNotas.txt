EJERCICIOS:

3.1 En el método bubbleSort() (listado 3-1) y en la herramienta de visualización, el índice interno siempre va de izquierda a derecha, encontrando el elemento más grande y llevándolo a cabo a la derecha. Modifica el método bubbleSort() para que sea bidireccional. Esto significa que el índice interno llevará primero el elemento más grande de izquierda a derecha como antes, pero cuando llegue al último, se invertirá y llevará el elemento más pequeño de derecha a izquierda. Necesita dos índices exteriores, uno a la derecha (el último antiguo) y otro a la izquierda. 

3.2 Añada un método llamado median() a la clase Array en el módulo SortArray.py (listado 3-4). Este método debe devolver el valor mediano de la matriz. (Recuerde que en un grupo de números, la mitad es más grande que la mediana y la otra mitad es más pequeña). Hazlo de la manera más fácil. 

3.3 Añada un método llamado deduplicate() a la clase Array en el módulo SortArray.py (listado 3-4) que elimina los duplicados de un array previamente ordenado sin alterar el orden. Puede utilizar cualquiera de los métodos de ordenación del programa de prueba para ordenar los datos. Se pueden imaginar esquemas en los que todos los elementos desde el lugar donde se descubrió un duplicado hasta el final de la matriz se desplazarían un espacio hacia abajo cada vez que se descubriera un duplicado, pero esto conduciría a un tiempo lento de O(N2), al menos cuando hay muchos duplicados. En su algoritmo, asegúrese de que ningún elemento se mueva más de una vez, sin importar cuántos duplicados haya. Esto te dará un algoritmo con tiempo O(N).

3.4 Otra clasificación simple es la clasificación par-impar. La idea es hacer repetidamente dos pasadas a través de la matriz. En el primer paso, se observan todos los pares de elementos, a[j] y a[j + 1], donde j es impar (j = 1, 3, 5, ...). Si sus valores de clave están desordenados, los intercambia. En la segunda pasada, se hace lo mismo con todos los valores pares (j = 0, 2, 4, ...). Estas dos pasadas se realizan repetidamente hasta que se ordena la matriz. Añada un método oddEvenSort() a la clase Array en el módulo SortArray.py (listado 3-4). Realice el bucle exterior hasta que no se produzcan intercambios para ver cuántas pasadas se necesitan; Un paso incluye el intercambio de pares pares e impares. Asegúrese de que funcione para cantidades variables de datos y en pedidos iniciales buenos y malos. Después de probar cuántas pasadas se necesitan antes de que no se produzcan más intercambios, determine el número máximo de pasadas del bucle externo en función de la longitud de la matriz de entrada. La ordenación par-impar es realmente útil en un entorno de multiprocesamiento, donde un procesador separado puede operar en cada par impar simultáneamente y luego en cada par par. Debido a que los pares impares son independientes entre sí, cada par puede ser verificado (e intercambiado, si es necesario) por un procesador diferente. Esto hace que la clasificación sea muy rápida. 

3.5 Modifique el método insertionSort() en SortArray.py (Listado 3-4) para que cuente el número de copias y el número de comparaciones de elementos que realiza durante una clasificación y muestre los totales. Debe observar la condición del bucle en el bucle while interno y contar cuidadosamente las comparaciones de artículos. Utilice este programa para medir el número de copias y comparaciones de diferentes cantidades de datos ordenados inversamente. ¿Los resultados verifican la eficiencia de O(N2)? Haga lo mismo con los datos casi ordenados (solo unos pocos elementos fuera de lugar). ¿Qué se puede deducir sobre la eficiencia de este algoritmo para datos casi ordenados? 

3.6 Esta es una forma interesante de eliminar elementos con claves duplicadas de una matriz. La ordenación por inserción utiliza un algoritmo de bucle dentro de un bucle que compara todos los elementos de la matriz con los elementos parcialmente ordenados hasta el momento. Una forma de eliminar elementos con claves duplicadas sería modificar el algoritmo de la clase Array en el módulo SortArray.py (Listado 3-4) para que elimine los duplicados a medida que ordena. Este es un enfoque: cuando se encuentra una clave duplicada, en lugar de copiar el duplicado en la celda de la matriz en su posición ordenada, cambie la clave del elemento marcado para que sea un valor especial que se trate como inferior a cualquier otra clave posible. Con ese valor de clave bajo, se mueve automáticamente a su lugar al principio de la matriz. Al realizar un seguimiento de cuántos duplicados se encuentran, conoce el final de los duplicados y el comienzo de los elementos restantes en la matriz. Cuando termina el bucle externo, el algoritmo tendría que hacer una pasada más para cambiar las claves únicas a las celdas ocupadas por los duplicados. Escriba un método insertionSortAndDedupe() que realice esta operación. Asegúrese de probar que funciona con todos los diferentes tipos de datos de matriz de entrada.